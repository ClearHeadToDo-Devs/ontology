# Schema Generation Design Decision

**Status:** Experimental
**Date:** 2025-10-29
**Version:** v3.1.0
**Decision:** Generate both JSON Schema and JSON Type Definition (JTD) from ontology

## Context

The Actions Vocabulary follows an "ontology-driven development" approach where:

```
OWL Ontology + SHACL → Schema Generation → Application Code → Data
(Semantic Truth)       (Small Waist)        (Implementations)   (Instances)
```

We need to bridge from our formal ontology (BFO/CCO-aligned OWL) to practical application code (Rust CLI, TypeScript web apps, tree-sitter parser). This requires generating schemas that can:

1. **Validate data** at runtime (user input, API requests)
2. **Generate type-safe code** at compile time (Rust structs, TypeScript interfaces)
3. **Maintain semantic consistency** with the ontology

## The Problem

A single schema language cannot optimally serve both purposes:

### JSON Schema Strengths
- ✅ Rich validation capabilities (regex patterns, conditional logic)
- ✅ Extensive ecosystem (validators, documentation generators)
- ✅ OpenAPI integration
- ✅ Human-readable metadata (descriptions, examples)

### JSON Schema Weaknesses for Code Generation
- ❌ Verbose type definitions
- ❌ Generic integer type (no distinction between uint8, int32, etc.)
- ❌ String-based enums (not type-safe enums)
- ❌ Complex schemas → complex generated code

### JTD Strengths
- ✅ Precise integer types (uint8, int16, int32 - maps to language types)
- ✅ Simple, minimal schemas
- ✅ Designed explicitly for code generation
- ✅ Clean mapping to statically-typed languages
- ✅ Official code generators (Rust, TypeScript, Go, Python)

### JTD Weaknesses
- ❌ No 64-bit integers (JSON precision issues)
- ❌ No pattern matching or regex
- ❌ No conditional validation
- ❌ Smaller ecosystem than JSON Schema
- ❌ **EXPERIMENTAL** for our use case

## Decision: Generate Both

We will generate **both** JSON Schema and JTD from the same OWL+SHACL source.

```
┌─────────────────────────────────────────┐
│  OWL Ontology + SHACL Shapes            │
│  (Single Source of Truth)               │
└─────────────────┬───────────────────────┘
                  │
      ┌───────────▼──────────┐
      │  Schema Generators   │
      │  (Python scripts)    │
      └───────────┬──────────┘
                  │
    ┌─────────────┼─────────────┐
    │             │             │
┌───▼────────┐ ┌─▼──────────┐ ┌▼─────────┐
│ JSON Schema│ │    JTD     │ │  SHACL   │
│ (.schema   │ │ (.jtd.json)│ │ (future) │
│  .json)    │ │            │ │          │
└───┬────────┘ └─┬──────────┘ └┬─────────┘
    │            │             │
    │            │             │
┌───▼──────┐ ┌──▼─────────┐ ┌─▼────────┐
│ Runtime  │ │ Compile    │ │ RDF      │
│ Validate │ │ Codegen    │ │ Validate │
│          │ │            │ │ (future) │
│ • APIs   │ │ • Rust     │ │          │
│ • Forms  │ │ • TypeScrip│ │          │
│ • Input  │ │ • Go       │ │          │
└──────────┘ └────────────┘ └──────────┘
```

## Use Cases

### Use JSON Schema For:
1. **Runtime validation** of user input (web forms, CLI arguments)
2. **API documentation** (OpenAPI specifications)
3. **Complex validation rules** (UUID patterns, date formats, business logic)
4. **Ecosystem integration** (existing tools expect JSON Schema)

### Use JTD For:
1. **Code generation** for Rust CLI (`clearhead-cli`)
2. **TypeScript types** for web applications
3. **Tree-sitter grammar** integration (simpler to parse)
4. **Inter-process communication** schemas (clean type mappings)

## Comparison Example

### Input: OWL + SHACL
```turtle
# OWL: Structure
actions:ActionPlan a owl:Class .
actions:hasPriority rdfs:range xsd:integer .

# SHACL: Constraints
actions:ActionPlanShape sh:property [
    sh:path actions:hasPriority ;
    sh:minCount 1 ;
    sh:minInclusive 1 ;
    sh:maxInclusive 4 ;
] .
```

### Output 1: JSON Schema (validation-focused)
```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "type": "object",
  "title": "ActionPlan",
  "description": "A directive information content entity...",
  "properties": {
    "priority": {
      "type": "integer",
      "minimum": 1,
      "maximum": 4,
      "description": "Eisenhower matrix priority (1=urgent+important, 4=neither)"
    },
    "state": {
      "type": "string",
      "enum": ["NotStarted", "InProgress", "Completed", "Blocked", "Cancelled"],
      "description": "Current state of the action process"
    }
  },
  "required": ["priority", "state"]
}
```

### Output 2: JTD (code-gen-focused)
```json
{
  "metadata": {
    "description": "A directive information content entity...",
    "typescriptType": "ActionPlan"
  },
  "properties": {
    "priority": { "type": "uint8" },
    "state": {
      "enum": ["NotStarted", "InProgress", "Completed", "Blocked", "Cancelled"]
    }
  }
}
```

### Generated Rust Code (from JTD)
```rust
// Generated by jtd-codegen from ActionPlan.jtd.json
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct ActionPlan {
    pub priority: u8,  // Perfectly sized! (vs i64 from JSON Schema)
    pub state: ActionState,  // Type-safe enum!
}

#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq, Eq)]
#[serde(rename_all = "PascalCase")]
pub enum ActionState {
    NotStarted,
    InProgress,
    Completed,
    Blocked,
    Cancelled,
}
```

Compare this to code generated from JSON Schema (via quicktype):
```rust
// From JSON Schema - less optimal
pub struct ActionPlan {
    pub priority: i64,      // Unnecessarily large type
    pub state: String,      // Not type-safe!
}
```

## Implementation

### File Organization
```
schemas/
├── action.schema.json           # JSON Schema (validation)
├── rootaction.schema.json
├── actions-combined.schema.json
├── jtd/                         # JTD (code generation)
│   ├── actionplan.jtd.json
│   ├── rootactionplan.jtd.json
│   └── actions-combined.jtd.json
```

### Generation Commands
```bash
# Generate JSON Schema (production-ready)
uv run python scripts/generate_json_schema.py

# Generate JTD (experimental)
uv run python scripts/generate_jtd.py

# Generate both
make schemas
```

### Code Generation Workflow
```bash
# Rust CLI
jtd-codegen schemas/jtd/actionplan.jtd.json \
  --rust-out clearhead-cli/src/models/ \
  --rust-edition 2021

# TypeScript web app
jtd-codegen schemas/jtd/actionplan.jtd.json \
  --typescript-out web/src/types/
```

## Risks and Mitigation

### Risk 1: Schema Drift
**Risk:** JSON Schema and JTD could diverge over time.

**Mitigation:**
- Both generated from same OWL+SHACL source
- Automated tests compare outputs
- CI/CD pipeline regenerates both on ontology changes

### Risk 2: JTD Limitations
**Risk:** JTD cannot express all validation rules from SHACL.

**Mitigation:**
- Use JSON Schema for validation, JTD for code generation
- Document which constraints apply to which schema format
- JTD focuses on type structure, not validation logic

### Risk 3: Maintenance Burden
**Risk:** Maintaining two generators increases complexity.

**Mitigation:**
- Generators share common OWL parsing logic
- JTD generator is simpler (fewer features)
- Clear separation of concerns (validation vs codegen)

### Risk 4: Experimental Status
**Risk:** JTD is newer and less proven than JSON Schema.

**Mitigation:**
- Mark as **EXPERIMENTAL** in documentation
- JSON Schema remains the primary validation mechanism
- JTD is an optional enhancement for code generation
- Can be removed if it doesn't provide value

## Evaluation Criteria

We will evaluate this dual-schema approach after 3-6 months based on:

1. **Code Quality:** Is generated code cleaner/more idiomatic?
2. **Developer Experience:** Does JTD improve or complicate the workflow?
3. **Maintenance Cost:** Is maintaining two generators worth the benefit?
4. **Adoption:** Are downstream projects (Rust CLI, web app) using JTD effectively?

### Success Metrics
- ✅ Generated Rust code has appropriate integer sizes (u8, u16 vs i64)
- ✅ Type-safe enums in generated code
- ✅ Reduced manual type definitions in Rust/TypeScript
- ✅ Both schemas stay in sync with ontology

### Failure Criteria
- ❌ JTD schemas frequently out of sync with JSON Schema
- ❌ Generated code requires significant manual fixes
- ❌ Developers bypass JTD and write manual types
- ❌ Maintenance burden outweighs benefits

## Alternatives Considered

### Alternative 1: JSON Schema Only
**Pros:** Single source, simpler maintenance
**Cons:** Poor code generation quality, verbose types
**Decision:** Rejected - code quality matters for Rust CLI

### Alternative 2: JTD Only
**Pros:** Simpler schemas, better code generation
**Cons:** Weaker validation, smaller ecosystem
**Decision:** Rejected - need JSON Schema for validation/documentation

### Alternative 3: Protobuf
**Pros:** Excellent code generation, binary efficiency
**Cons:** Requires separate protobuf definitions, doesn't align with ontology
**Decision:** Rejected - breaks ontology-driven development model

### Alternative 4: GraphQL Schema
**Pros:** Good for APIs, type-safe
**Cons:** Tied to GraphQL, doesn't help Rust CLI
**Decision:** Rejected - too specific to GraphQL use case

### Alternative 5: Manual Type Definitions
**Pros:** Full control
**Cons:** Manual maintenance, drift from ontology
**Decision:** Rejected - violates ontology-driven development principle

## Related Documentation

- [RFC 8927 - JSON Type Definition](https://datatracker.ietf.org/doc/html/rfc8927)
- [JTD Codegen Tool](https://github.com/jsontypedef/json-typedef-codegen)
- [JSON Schema Specification](https://json-schema.org/)
- [BFO_CCO_ALIGNMENT.md](./BFO_CCO_ALIGNMENT.md) - Ontology design
- [README.md](./README.md) - Project overview
- [CLAUDE.md](./CLAUDE.md) - Development guide

## Revision History

| Date | Version | Changes |
|------|---------|---------|
| 2025-10-29 | 1.0 | Initial decision document - JTD generation is experimental |

## Conclusion

By generating both JSON Schema and JTD from our OWL ontology, we get:

1. **Best of both worlds:** Validation power + code generation quality
2. **Single source of truth:** Ontology drives all schemas
3. **Flexibility:** Can use the right tool for each job
4. **Experimentation:** Can evaluate JTD without committing fully

This approach aligns with our ontology-driven development philosophy while acknowledging that different downstream use cases have different requirements.

**Status:** JTD generation is **EXPERIMENTAL** as of v3.1.0. JSON Schema remains the production-ready validation mechanism.
